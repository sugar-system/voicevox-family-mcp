import type { CallToolResult } from '@modelcontextprotocol/sdk/types';
import type { IVoiceSynthesisService } from '@/api/voice-synthesis-service';
import type { McpServerConfig } from '@core/mcp-server-config';
import { ToolFactory, type IToolFactory } from './tool-factory';
import { z } from 'zod';
import axios from 'axios';
/**
 * MCPクライアントからのリクエストパラメータ
 */
export interface SpeakRequestParams {
  server_id: string;
  text: string;
  language: string;
  speaker_id: number;
  model_id: number;
  assist_text_weight: number;
  auto_split: boolean;
  length: number;
  noise: number;
  noisew: number;
  sd_ratio: number;
  split_interval: number;
  style: string;
  style_weight: number;
}

export function createSpeakResponseFactory(
  voiceServices: Map<string, IVoiceSynthesisService>,
  config: McpServerConfig,
): IToolFactory<typeof speakRequestParamsSchema.shape> {
  // デフォルトの話者IDの設定（サーバータイプによって異なる）
  // Aivis Speech
  // Anneli - ノーマル: 888753760
  //
  // VOICEVOX
  // 四国めたん（あまあま）: 0
  const getDefaultSpeakerId = (serverType: string): number => {
    switch (serverType) {
      case 'aivis':
        return 888753760;
      case 'voicevox':
        return 0;
      default:
        return 0;
    }
  };

  // デフォルトサーバーIDを取得（最初のサーバーを使用）
  const defaultServerId = config.servers.length > 0 ? config.servers[0].id : '';
  const defaultServerType = config.servers.length > 0 ? config.servers[0].type : 'voicevox';

  const speakRequestParamsSchema = z.object({
    server_id: z.string().default(defaultServerId),
    text: z.string(),
    style: z.string().default('Neutral'),
    language: z.string().default('JP'),
    speaker_id: z.number().default(getDefaultSpeakerId(defaultServerType)),
    model_id: z.number().default(0),
    style_weight: z.number().default(1.0),
    sd_ratio: z.number().default(0.2),
    noise: z.number().default(0.6),
    noisew: z.number().default(0.8),
    length: z.number().default(1.0),
    auto_split: z.boolean().default(false),
    split_interval: z.number().default(0.5),
    assist_text_weight: z.number().default(1.0),
  });

  const speakResponseHandler = async (
    params: SpeakRequestParams,
    _extra?: unknown,
  ): Promise<CallToolResult> => {
    try {
      // 指定されたサーバーIDのサービスを取得
      const voiceService = voiceServices.get(params.server_id);
      if (!voiceService) {
        throw new Error(
          `Server not found: ${params.server_id}. Available servers: ${Array.from(voiceServices.keys()).join(', ')}`,
        );
      }

      // サーバー情報を取得
      const serverInfo = config.servers.find(s => s.id === params.server_id);
      const serverType = serverInfo?.type ?? 'unknown';
      const serverUrl = serverInfo?.url ?? 'unknown';

      console.error(`Converting to speech: "${params.text}" with speaker ${params.speaker_id}`);
      console.error(`Using server: ${params.server_id} (${serverType}) at ${serverUrl}`);

      // ステップ1: AudioQueryを作成
      const audioQuery = await voiceService.createAudioQuery({
        text: params.text,
        speaker: params.speaker_id,
      });

      // パラメータをカスタマイズ
      audioQuery.intonationScale = params.style_weight;
      audioQuery.speedScale = params.length;
      audioQuery.volumeScale = 1.0;

      // kanaフィールドに読み上げるテキストを設定
      audioQuery.kana = params.text;

      // ステップ2: 音声合成
      const audioData = await voiceService.synthesizeSpeech({
        speaker: params.speaker_id,
        query: audioQuery,
      });

      // ステップ3: 音声を再生
      await voiceService.playAudio(audioData);

      return {
        content: [
          {
            type: 'text',
            text: `Successfully spoke: "${params.text}" with speaker ID ${params.speaker_id} using server ${params.server_id} (${serverType})`,
          },
        ],
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error('TTS Error:', errorMessage);
      if (axios.isAxiosError(error) && error.response) {
        console.error('API Response Status:', error.response.status);
        console.error('API Response Data:', error.response.data);
      }
      throw new Error(`TTS failed: ${errorMessage}`);
    }
  };

  return new ToolFactory(
    'speak_response',
    'Plays synthesized speech generated by the specified TTS server. ' +
      'Available speaker IDs and server IDs can be obtained using the "list_speakers" tool.',
    speakRequestParamsSchema.shape,
    speakResponseHandler,
  );
}
